#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <ctime>

using namespace std;

struct Node {
    float value;
    string comments;
    Node *next;
};

void addToHead(int val, Node *&hd);
void addToTail(int val, Node *&hd);
void output(Node * hd);

int main()
{
    Node *head = nullptr;
    int count = 0;
    double reviewScore;
    char response;

    // create a linked list of size SIZE with random numbers 0-99
    while (response != 'n' || response != 'N') 
    {
        int insertion;
        //asks the user whether they would like to insert the previously obtained random value at the head or the tail end of the linked list
        cout << "Which linked list method should we use?\n";
        cout << setw(15) << "[1] New nodes are added at the head of the linked list\n";
        cout << setw(15) << "[2] New nodes are added at the tail of the linked list\n";
        cin >> insertion;
        cin.ignore();
        //determines, which function will be called to either add the value found to the front or back of the linked list respectively
        if(insertion == 1)
            addToHead(reviewScore, head);
        else if(insertion == 2)
            addToTail(reviewScore, head);

        count++;
    }

    return 0;
}

void output(Node * hd) {
    if (!hd) {
        cout << "Empty list.\n";
        return;
    }
    int count = 1;
    Node * current = hd;
    while (current) {
        cout << "Review #" << count++ << ": " << current->value << ": " << current->comments << endl;
        current = current->next;
    }
    cout << endl;
}

void addToHead(int val, Node *&hd)
{
    Node *newVal = new Node;
        
    // if this is the first node, it's the new head
        if (!hd) { 
            hd = newVal;
            newVal->next = nullptr;
            newVal->value = val;
        }
        // if its a second or subsequent node; place at the head
        else {
            newVal->next = hd;
            newVal->value = val;
            hd = newVal;
        }
}

void addToTail(int val, Node *&hd)
{
     Node *newVal = new Node;
    // adds node at head if list is empty, as that position would also technically be the tail end
    if (hd == nullptr) 
    {
        hd = newVal;
        newVal->next = nullptr;
        newVal->value = val;
    }
    //iff the list is not empty, the function will traverse the array until it reaches the last value, at which point it will add the designated value to the end of the list
    else if (hd != nullptr)
    {
        Node *current = hd;
        while(current->next != nullptr)
            {
            current = current->next;
            }
        current->next = newVal;
        newVal->next = nullptr;
        newVal->value = val;
    }
}